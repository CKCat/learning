## 什么是所有权

所有权是 Rust 用于如何管理内存的一组规则。所有程序都必须管理其运行时使用计算机内存的方式。

所有权规则：

1. Rust 中的每一个值都有一个所有者。
1. 值在任一时刻有且只有一个所有者。
1. 当所有者离开作用域，这个值将被丢弃。

### String 类型
两个 String 类型的变量进行赋值时，会发生移动。

```rust
let s1 = String::from("hello");
let s2 = s1; // 这里将会发生移动，s1 将不再有效
```

如果需要拷贝，则应该使用 clone() 方法。
```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 这里将会发生深拷贝
```
4 种基本的标量类型由于在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。

Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。

作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy。

### 所有权与函数

向函数传递值可能会移动或者复制，就像赋值语句一样。

返回值也可以转移所有权。

Rust 提供了一个不用获取所有权就可以使用值的功能，做引用。

## 引用与借用

引用像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。

与使用 `&` 引用相反的操作是解引用，它使用解引用运算符 `*`。

我们将创建一个引用的行为称为借用。

默认不允许修改引用的值。如果需要修改引用的值，则需要使用可变引用 `&mut`，如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。

在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

## Slice 类型

slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它没有所有权。

字符串 slice 是 String 中一部分值的引用，可以使用一个由中括号中的 `[starting_index..ending_index]` 指定的 range 创建一个 slice，其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice 最后一个位置的后一个值。**在其内部，slice 的数据结构存储了 slice 的开始位置和长度。**

如果一个不可变的slice 指向了一个可变的引用，在不使用这个不可变的slice 之前都不可以修改可变的引用。

字符串字面值就是 slice ，类型是 `&str` ，它是一个指向二进制程序特定位置的 slice。

如果参数类型为 `&str` ，则可以传递整个 String 的 slice 或对 String 的引用。


