IDA 开箱即支持 40 多种文件格式。 其中大多数是结构化文件格式——具有定义好的文件头和元数据——因此 IDA 可以自动识别并处理它们。

然而，有时你手上只有一段没有任何文件头的代码（例如 shellcode 或原始固件），但你仍想在 IDA 中分析它。 这种情况下，你可以使用 二进制文件加载器。 即使文件被识别为其他文件格式，该加载器也始终可用。

### 处理器选择（Processor selection）

由于原始二进制文件没有元数据，IDA 无法知道应使用哪个处理器模块，因此你需要手动选择正确的处理器。 默认会选择 metapc（负责 x86 和 x64 反汇编），但你可以从列表中选择其他处理器（双击即可更改）。

![](assets/2021/05/binfile_default.png)

### 内存加载地址（Memory loading address）

没有元数据时，IDA 也不知道应将数据放置在内存的哪个地址，因此你可能需要手动指定。

`Loading segment` 和 `Loading offset` 字段仅适用于 x86 系列。 如果加载的代码使用平坦内存模型（如 32 位保护模式或 64 位长模式），则应将 `Loading segment` 保持为 0，并在 `Loading offset` 中指定地址。

其他处理器（如 ARM、MIPS 或 PPC）不使用这些字段，而是在你确认初始选择后提示你设置内存布局。

![](assets/2021/05/binfile_memory.png)

在该对话框中，你可以指定数据放置位置，以及是否创建额外的 RAM 段。

默认情况下，整个文件会被放置在 ROM 段的地址 0，但你可以指定不同的地址，或通过更改文件偏移和加载大小，仅加载文件的一部分。

### 指令位宽（Code bitness）

对于某些处理器，指令解码会依赖当前模式，例如：

- PC（16 位模式、32 位保护模式、64 位长模式）
- ARM（AArch32 或 AArch64）

在这种情况下，你可能会多收到一个额外的提示问题。

![](assets/2021/05/binfile_bitness.png)

### 开始反汇编（Start disassembling）

文件加载完成后，IDA 无法自动决定如何反汇编它。

![](assets/2021/05/binfile_decoding.png)

正如对话框所提示的，你可以使用 C（Make Code）在看起来像有效指令的位置尝试解码。

通常情况下：

- shellcode 会在开头就有有效指令
- 大多数处理器的固件要么从最低地址开始，要么使用向量表（地址列表）指向代码

![](assets/2021/05/binfile_shellcode1-e1622214211102.png)  
![](assets/2021/05/binfile_shellcode2.png)

除了 shellcode 或固件外，二进制文件加载器还可以用来分析其他类型的文件，利用 IDA 强大的数据和代码标注功能。 例如，下图展示了一个在 IDA 中标注和添加注释的 PNG 文件：

![](assets/2021/05/binfile_png.png)

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-41-binary-file-loader
