之前我们讨论过如何通过 mapping copies of a variable 来减少伪代码中的变量数量。 但有时会遇到相反的问题：同一个变量被用于不同目的。

### Reused stack slots

一个常见情况是编译器会复用栈上的位置（无论是局部变量还是传入的栈参数），让它在不同阶段存放不同的数据。

```c
vtbl = DiaSymbol->vtbl;
vtbl->get_symTag(DiaSymbol, (int *)&DiaSymbol);
Symbol->Tag = (int)DiaSymbol;
```

在这里，`get_symTag` 的第二个参数显然是一个输出参数，它的含义和类型与调用前的 `DiaSymbol` 完全不同。

在这种情况下，可以使用 `Force new variable` 命令（快捷键 `Shift–F`）。

注意：有时在变量本身上右键不会显示该选项，可以尝试在伪代码行的开头右键。

![](assets/2022/03/newvar1.png)

反编译器会在同一栈位置创建一个新变量，初始类型相同：

```c
IDiaSymbol *v14; // [esp+30h] [ebp+8h] FORCED BYREF

vtbl = DiaSymbol->vtbl;
vtbl->get_symTag(DiaSymbol, (int *)&v14);
Symbol->Tag = (int)v14;
```

自然，你可以修改它的类型和名字：

```c
int tag; // [esp+30h] [ebp+8h] FORCED BYREF

vtbl = DiaSymbol->vtbl;
vtbl->get_symTag(DiaSymbol, &tag);
Symbol->Tag = tag;
```

### 使用 union 表示多态变量

遗憾的是，`Force new variable` 在寄存器变量上不可用（截至 IDA 7.7）。 这种情况下，可以考虑使用 `union`。

例如，来自 `ntdll.dll` 的 `LdrRelocateImage` 函数片段：

```c
  int v6; // esi
  int v7; // eax
  int v8; // edi
  int v9; // eax

  v6 = 0;
  v20 = 0;
  v7 = RtlImageNtHeader(a1);
  v8 = v7;
  if ( !v7 )
    return -1073741701;
  v9 = *(unsigned __int16 *)(v7 + 24);
  if ( v9 == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
  {
    v18 = *(_DWORD *)(v8 + 52);
    v16 = 0;
  }
  else
  {
    if ( v9 != IMAGE_NT_OPTIONAL_HDR64_MAGIC )
      return -1073741701;
    v18 = *(_DWORD *)(v8 + 48);
    v16 = *(_DWORD *)(v8 + 52);
  }
```

`RtlImageNtHeader` 返回的是 `IMAGE_NT_HEADERS` 结构体指针。 调整原型和变量类型后，代码更清晰：

```c
  int v6; // esi
  PIMAGE_NT_HEADERS v7; // eax
  PIMAGE_NT_HEADERS v8; // edi
  int Magic; // eax
  int v10; // edx
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // ecx
  int v15; // [esp+Ch] [ebp-10h]
  unsigned int v16; // [esp+10h] [ebp-Ch]
  int v17; // [esp+10h] [ebp-Ch]
  unsigned int v18; // [esp+14h] [ebp-8h]
  char *v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h] BYREF

  v6 = 0;
  v20 = 0;
  v7 = RtlImageNtHeader(a1);
  v8 = v7;
  if ( !v7 )
    return -1073741701;
  Magic = v7->OptionalHeader.Magic;
  if ( Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
  {
    v18 = v8->OptionalHeader.ImageBase;
    v16 = 0;
  }
  else
  {
    if ( Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC )
      return -1073741701;
    v18 = v8->OptionalHeader.BaseOfData;
    v16 = v8->OptionalHeader.ImageBase;
  }
```

问题在于：

- 代码需要同时处理 32 位和 64 位 PE。
- 但 `PIMAGE_NT_HEADERS` 实际上是 32 位版本（`PIMAGE_NT_HEADERS32`），因此 `else` 分支可能不正确。
- 如果改成 `PIMAGE_NT_HEADERS64`，则 `if` 分支又会出错。

```c
  if ( Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
  {
    ImageBase = HIDWORD(v8->OptionalHeader.ImageBase);
    v16 = 0;
  }
  else
  {
    if ( Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC )
      return -1073741701;
    ImageBase = v8->OptionalHeader.ImageBase;
    v16 = HIDWORD(v8->OptionalHeader.ImageBase);
  }
```

由于 `v8` 在寄存器中，无法使用 `Force new variable`。可以定义一个 `union`，同时包含两种类型：

1. 打开 `Local Types` (`Shift–F1`)
2. 新建类型（`Ins`）
3. 输入定义：
   ```c
   union nt_headers
   {
    PIMAGE_NT_HEADERS32 hdr32;
    PIMAGE_NT_HEADERS64 hdr64;
   };
   ```
4. 将 `v8` 的类型改为 `nt_headers` 在 `if/else` 分支中使用 `Select union field` 选择正确的字段：

   ```c
    Magic = v7->OptionalHeader.Magic;
     if ( Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
     {
       ImageBase = v8.hdr32->OptionalHeader.ImageBase;
       ImageBaseHigh = 0;
     }
     else
     {
       if ( Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC )
         return -1073741701;
       ImageBase = v8.hdr64->OptionalHeader.ImageBase;
       ImageBaseHigh = HIDWORD(v8.hdr64->OptionalHeader.ImageBase);
     }
   ```

在这个例子中，差异不大，用注释也能解决，但在更复杂的场景下，`union` 的方式能显著提升可读性。 这种方法同样适用于栈变量。

参考:

[Hex-Rays interactive operation: Force new variable](https://www.hex-rays.com/products/decompiler/manual/cmd_force_lvar.shtml)

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-79-handling-variable-reuse
