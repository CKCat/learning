我们之前已经介绍过反编译器中使用的[自定义类型](https://hex-rays.com/blog/igors-tip-of-the-week-45-decompiler-types/)，但你可能还会遇到一些看起来像函数调用的特殊关键字。 这些关键字由反编译器使用，用来表示无法直接映射为标准 C 代码的操作，或者为了让输出更简洁。 它们在反编译器附带的 `defs.h` 头文件中有定义（位于 `plugins/hexrays_sdk/include` 目录下），这里给出常见情况的概览。

### Partial access macros（部分访问宏）

有时代码会访问一个大变量的较小部分。为了避免大量强制类型转换，反编译器使用辅助宏：

- `LOWORD(x)`、`LODWORD(x)` 返回变量 `x` 的低字节/字/双字（无符号）。
- `HIWORD(x)`、`HIDWORD(x)` 返回对应的高部分。
- `BYTE1(x)`、`BYTE2(x)` 等返回单独的字节（按内存顺序）。
- 带 `S` 前缀的版本（如 `SLOBYTE`、`SBYTE1`）返回有符号值。

⚠️ 注意：在大端处理器（如 PPC）上可能会引起混淆，因为低序字节存储在最高地址，因此需要用 `HIBYTE` 来访问。

示例： 一个 32 位变量 `0x1A2B3C4D` 在内存中的存储顺序：

```
LE BE
┌──┬──┐
│4D│1A├◄───LOBYTE
├──┼──┤
│3C│2B├◄───BYTE1
├──┼──┤
│2B│3C├◄───BYTE2
├──┼──┤
│1A│4D├◄───HIBYTE
└──┴──┘
```

### Combining values（组合值）

有时需要执行相反的操作：将两个小值组合成一个大值。

- `__PAIR16__`(high, low)：将两个 8 位值组合成一个 16 位值。
- `__PAIR32__`、`__PAIR64__`、`__PAIR128__`：对应更大尺寸。
- `__SPAIR16__` 等：返回有符号值。

与部分访问宏不同，这些宏不依赖内存顺序，而是通过位移实现，因此在 `LE` 和 `BE` 下结果相同。

### Bit and flag manipulations（位与标志操作）

某些汇编指令没有直接的 C 表示，因此使用自定义 helper：

- `__ROLn__(value, count)` / `__RORn__(value, count)`：`n` 字节的循环左移/右移（n=1,2,4,8）。
- `__OFADD__ `/ `__OFSUB__`：返回加法/减法的溢出标志。
- `__CFADD__` / `__CFSUB__`：返回进位标志。
- `__SETP__(x, y)`：表示由 `x-y` 生成的奇偶标志。

### Overflow-checking multiplications（溢出检查乘法）

现代编译器在某些情况下会自动添加溢出检查，例如 operator new[] 需要计算元素大小 × 数量。 如果溢出，可能导致分配错误。

- `is_mul_ok(count, elsize)`：检查 `count*elsize` 是否溢出。
- `saturated_mul(count, elsize)`：安全时返回乘积，否则返回该类型的最大值（如 `0xFFFFFFFF`），确保分配失败。

### Value coercion（值强制转换）

有时代码会将同一底层值当作不同类型使用。

著名的 Quake 快速平方根倒数函数就是例子：

```c
float InvSqrt(float x) {
    float xhalf = 0.5f * x;
    int i = *(int*)&x;
    i = 0x5f3759df - (i >> 1);
    x = *(float*)&i;
    x = x * (1.5f - xhalf * x * x);
    return x;
}

```

在优化后的代码中，这些转换可能只是寄存器间的简单移动。 反编译器使用特殊宏来表示：

- `COERCE_FLOAT(v)`、`COERCE_DOUBLE(v)`、`COERCE_LONG_DOUBLE(v)`：将位模式当作浮点数。
- `COERCE_UNSIGNED_INT(v)`、`COERCE_UNSIGNED_INT64(v)`：反向转换。
- `SLODWORD`：当浮点值被当作有符号整数时使用。

反编译后的伪代码示例：

```
double __cdecl InvSqrt(float a1) {
    float v2 = a1 * 0.5;
    return (float)((1.5 - v2 * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) >> 1))
        * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) >> 1)))
        * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) >> 1)));
}

```

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-67-decompiler-helpers
