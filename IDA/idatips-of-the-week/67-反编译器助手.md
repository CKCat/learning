We’ve already described [custom types](https://hex-rays.com/blog/igors-tip-of-the-week-45-decompiler-types/) used in the decompiled code, but you may also encounter some unusual keywords resembling function calls. They are used by the decompiler to represent operations which it was unable to map to nice C code, or just to make the output more compact. They are listed in the `defs.h` header file that is provided with the decompiler (can be found in `plugins/hexrays_sdk/include` in your IDA directory) but here is a high level overview of the commonly seen ones.  
我们已经介绍了反编译代码中使用的自定义类型，但您可能还会遇到一些类似函数调用的不寻常关键字。反编译器使用这些关键字来表示它无法映射到漂亮的 C 代码的操作，或者只是为了使输出更紧凑。它们列在反编译器提供的 `defs.h` 头文件中（可在 IDA 目录下的 `plugins/hexrays_sdk/include` 中找到），下面是常见关键字的高级概述。

### Partial access macros 部分访问宏

Sometimes the code may access smaller parts of a big variable. To not pollute the code with multitudes of casts, the decompiler uses helper macros for this purpose.   
有时，代码可能会访问一个大变量的较小部分。为了避免代码中出现大量的偏移，反编译器会为此使用辅助宏。

1.  `LOWORD(x),LOWORD(x),LODWORD(x)` return the lowest byte/word/dword of the variable `x` as an unsigned value;  
    `LOWORD(x),LOWORD(x),LODWORD(x)` 返回变量 `x` 的最低字节/字/字的无符号值；
2.  `HIWORD(x),HIWORD(x),HIDWORD(x)` return the corresponding high part;  
    `HIWORD(x),HIWORD(x),HIDWORD(x)` 返回相应的高字节；
3.  `BYTE1(x), BYTE2(x)` etc. return individual bytes in the memory order. The variable is considered to start at byte 0 in memory.  
    `BYTE1(x), BYTE2(x)` 等按内存顺序返回单个字节。变量被视为从内存中的第 0 个字节开始。
4.  same macros but with the S prefix (`SLOBYTE`, `SBYTE1` etc.) return signed values.  
    带 S 前缀的相同宏（ `SLOBYTE` 、 `SBYTE1` 等）返回带符号的值。

Note: this approach may lead to somewhat confusing situations on big endian processors like PPC. Because big-endian data is stored starting from the high byte, the low-order byte of it is stored at the highest memory address and so is accessed using the `HIBYTE` macro. For example, consider a 32-bit variable containing value 0x1A2B3C4D. It will be stored in memory in different order on little-endian(LE) and big-endian(BE) platforms:  
注意：在 PPC 等大端处理器上，这种方法可能会导致一些令人困惑的情况。因为大二进制数据是从高字节开始存储的，其低阶字节存储在最高内存地址处，因此使用 `HIBYTE` 宏访问。例如，一个 32 位变量的值为 0x1A2B3C4D。在小双位（LE）和大双位（BE）平台上，它在内存中的存储顺序是不同的：

```
&nbsp;LE BE
┌──┬──┐
│4D│1A├◄───LOBYTE
├──┼──┤
│3C│2B├◄───BYTE1
├──┼──┤
│2B│3C├◄───BYTE2
├──┼──┤
│1A│4D├◄───HIBYTE
└──┴──┘
```

### Combining values 组合数值

Sometimes the compiler needs to represent the opposite operation: two values are combined to make a larger one. For this, “pair” macros are used:  
有时，编译器需要表示相反的操作：将两个值合并成一个更大的值。为此，需要使用 "对 "宏：

1.  `__PAIR16__(high, low)` creates a 16-bit value from two 8-bit ones. Unlike partial accesses macros, it does not depend on the memory order but uses simple bit shifts, so the result is the same for little- and big-endian code. For example, `__PAIR16__(0x1A, 0x2B)` returns in `0x1A2B` in either situation;  
    `__PAIR16__(high, low)` 用两个 8 位 1 创建一个 16 位值。与部分访问宏不同的是，它不依赖于内存顺序，而是使用简单的位移，因此小端和大端代码的结果是一样的。例如， `__PAIR16__(0x1A, 0x2B)` 在两种情况下都会返回 `0x1A2B` ；
2.  `__PAIR32__`, `__PAIR64__`, `__PAIR128__` perform the corresponding operation for bigger-sized values;  
    `__PAIR32__` , `__PAIR64__` , `__PAIR128__` 对较大的数值执行相应的操作；
3.  `__SPAIR16__` etc. return signed values.  
    `__SPAIR16__` 等返回带符号的值。

### Bit and flag manipulations  
位和标志操作

 Some assembly instructions do not have simple C representation so custom helper functions are used.  
有些汇编指令没有简单的 C 语言表示法，因此需要使用自定义辅助函数。

1.  `__ROLn__(value, count)` and `__RORn__(value, count)` (n=1,2,4,8) represent n-byte left and right bit rotates;  
    `__ROLn__(value, count)` 和 `__RORn__(value, count)` （n=1,2,4,8）表示 n 个字节的左右位旋转；
2.  `__OFADD__` and `__OFSUB__` return the overflow flag of addition(subtraction) operation on two values.  
    `__OFADD__` 和 `__OFSUB__` 返回两个值的加法（减法）运算的溢出标志。
3.  `__CFADD__` and `__CFSUB__` perform the same for carry flag.  
    `__CFADD__` 和 `__CFSUB__` 对进位标志执行同样的操作。
4.  `__SETP__(x, y)` is used to represent the parity flag generated by expression x-y.  
    `__SETP__(x, y)` 用于表示表达式 x-y 生成的奇偶校验标志。

### Overflow-checking multiplications  
乘法溢出检查

Recent compilers started adding overflow checks in common situations. For example, when calling `operator new[]`,  behind the scenes the compiler has to multiply the size of the elements by their count. If this operation overflows, wrong value may be produced, leading to under-allocation or allocation failure. Programmers may also add manual overflow checks. The following helper functions are used to represent such code patterns:  
最近的编译器开始在常见情况下添加溢出检查。例如，在调用 `operator new[]` 时，编译器需要在幕后将元素的大小乘以元素的数量。如果该操作发生溢出，可能会产生错误的值，导致分配不足或分配失败。程序员也可以手动添加溢出检查。以下辅助函数用于表示此类代码模式：

1.  `is_mul_ok(count, elsize)` represents overflow check on the result of `count*elsize`. It is presumed to return true if the overflow does not happen.  
    `is_mul_ok(count, elsize)` 表示对 `count*elsize` 的结果进行溢出检查，如果溢出没有发生，则假定返回 true。
2.  `saturated_mul(count, elsize)` returns either the result of multiplication if it can be calculated safely, or the maximum unsigned integer value of the corresponding size (e.g. `0xFFFFFFFF`). The latter should ensure that the allocation fails in case of overflow. This pattern is commonly used in calls to `operator new[]` in recent versions of Visual C++.  
    如果乘法结果可以安全计算， `saturated_mul(count, elsize)` 返回乘法结果，或者返回相应大小的最大无符号整数值（例如 `0xFFFFFFFF` ）。后者应确保在溢出时分配失败。在 Visual C++ 的最新版本中，这种模式常用于对 `operator new[]` 的调用。

### Value coercion 数值强制

Sometimes the code treats the same underlying value as different types. For example, the famous inverse square root function from Quake treats a 32-bit floats as an integers and vice versa:  
有时，代码会将相同的底层值视为不同的类型。例如，Quake 中著名的反平方根函数将 32 位浮点视为整数，反之亦然：

```
float&nbsp;InvSqrt (float&nbsp;x){
&nbsp;&nbsp;&nbsp;&nbsp;float xhalf = 0.5f*x;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i = *(int*)&amp;x;
&nbsp;&nbsp;&nbsp;&nbsp;i = 0x5f3759df - (i&gt;&gt;1);
&nbsp;&nbsp;&nbsp;&nbsp;x = *(float*)&amp;i;
&nbsp;&nbsp;&nbsp;&nbsp;x = x*(1.5f - xhalf*x*x);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x;
}
```

Although in the source code this conversion is represented using casts and dereferences, in the optimized code they may be replaced by simple moves between registers, especially when using SSE or AVX instructions which use the same registers to store both floating-point and integer values. Thus the decompiler has to use special macros to represent such code:  
虽然在源代码中，这种转换是通过投类和反引用来表示的，但在优化后的代码中，它们可能会被寄存器之间的简单移动所取代，特别是在使用 SSE 或 AVX 指令时，这些指令使用相同的寄存器来存储浮点和整数值。因此，反编译器必须使用特殊的宏来表示这类代码：

1.  `COERCE_FLOAT(v)`, `COERCE_DOUBLE(v)`, `COERCE_LONG_DOUBLE(v)` are used to treat the bit pattern of `v` as the corresponding floating-point type.  
    `COERCE_FLOAT(v)` , `COERCE_DOUBLE(v)` , `COERCE_LONG_DOUBLE(v)` 用于将 `v` 的位模式视为相应的浮点类型。
2.  `COERCE_UNSIGNED_INT(v)` and `COERCE_UNSIGNED_INT64(v)` are used for the opposite conversions.  
    `COERCE_UNSIGNED_INT(v)` 和 `COERCE_UNSIGNED_INT64(v)` 用于相反的转换。
3.  You may also see `SLODWORD` when a floating-point value is treated as a signed integer.  
    当浮点数值被视为带符号整数时，您还可能看到 `SLODWORD` 。

For example, here’s how pseudocode for the above function looks like when decompiled:  
例如，下面是上述函数反编译后的伪代码：

```
double __cdecl InvSqrt(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = a1 * 0.5;
  return (float)((1.5
                - v2 * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) &gt;&gt; 1)) * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) &gt;&gt; 1)))
               * COERCE_FLOAT(0x5F3759DF - (SLODWORD(a1) &gt;&gt; 1)));
}
```