假设你在二进制文件中找到一个看起来很有价值的字符串，跟随交叉引用跳转到使用它的函数，然后将其反编译，结果却发现伪代码中完全没有出现这个字符串。 这是怎么回事呢？

在这种情况下，通常有帮助的方法是：

- 打开两个同步的 反汇编 `<->` 伪代码 视图，
- 然后滚动查看，寻找异常之处。

经验法则：

- 大多数伪代码行应该对应一条或几条汇编指令；
- 大多数汇编指令（除了函数序言或结尾等可跳过的部分）也应该对应某行伪代码。

### 一个奇怪的案例

在某个示例中：

- 伪代码里只有一个函数调用，
- 但它不仅对应了调用指令，还“吞掉”了后面一堆看似无关的指令。

![](assets/2023/10/misssing-noret1.png)

接着你会看到一些指令完全没有映射到伪代码中。

![](assets/2023/10/misssing-noret2.png)

当你把鼠标悬停在调用上时，会发现一个线索：它被标记为 no-return（无返回）。

![](assets/2023/10/misssing-noret3.png)

然而，调用之后显然还有有效代码，这说明这是一个误判。

### 解决方法

- 去掉函数原型中的 `__noreturn` 属性（提示：快捷键 `Y`）。
- 这样就能恢复缺失的代码，并且指令映射也会变得正常。

![](assets/2023/10/misssing-noret4.png)

**注意：**

在某些情况下，你可能还需要在函数属性中清除 `noret` 标志，否则 `__noreturn` 会不断被加回来。

### 为什么会误判？

函数被错误标记为无返回的原因有很多，例如：

- 它可能以一个无限循环结尾；
- 或者所有路径都只通向其他无返回函数；
- 也可能是其他分析问题导致的。

如果你发现多个类似的函数，值得进一步调查。

### 特殊情况

有时，即使函数确实不会返回，你仍然可能在调用后看到一些“看起来有效”的代码。 这可能是由于：

- 编译器没有推断出该函数不会返回；
- 使用了旧编译器，没有进行死代码删除优化；
- 编译时的优化设置不同；
- 或者反编译器的假设不正确。

相关内容：

[Igor’s Tip of the Week #126: Non-returning functions](https://hex-rays.com/blog/igors-tip-of-the-week-126-non-returning-functions/)

[Igor’s Tip of the Week #159: Where’s my code? The case of not-so-constant data](https://hex-rays.com/blog/igors-tip-of-the-week-159-wheres-my-code-the-case-of-not-so-constant-data/)

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-162-wheres-my-code-the-case-of-no-return-call
