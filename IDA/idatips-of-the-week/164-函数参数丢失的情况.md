让我们来看一个从 Windows x86 二进制文件反编译得到的片段：

![](assets/2023/11/missing-arg1.png)

同一个函数被调用了两次，传入了相同的参数，但最后一次调用似乎并没有使用 `GetComputerNameExW` 的返回结果。

切换到反汇编视图后，我们可以看到：在每次调用之前，`eax` 都被初始化为一个字符串地址。

![](assets/2023/11/missing-arg2.png)

然而反编译器并没有考虑这一点，因为在 x86 平台上，栈才是传递参数的常规方式，而 `eax` 通常只是一个临时寄存器。

### 解决方法

一种方法是：

- 编辑 `sub_10006FC7` 的函数原型，
- 使用 `__usercall` 调用约定，
- 并手动将 `eax` 添加为参数。

但如果该函数就在同一个二进制文件中，更简单的做法是：

- 直接进入函数内部并反编译它，
- 这样反编译器就能看到它在初始化之前确实使用了 `eax`，
- 因此会自动将其加入参数列表。

![](assets/2023/11/missing-arg3.png)

此外，`esi` 也会被检测为一个参数。返回到调用者时，你就能看到之前缺失的参数被正确传递了。

![](assets/2023/11/missing-arg4.png)

**注意事项**
使用非标准、自定义调用约定，通常意味着：

- 该函数可能是手写汇编，
- 或者启用了 全程序优化（`LTO` 或 `LTCG`）。

相关内容：

[Igor’s tip of the week #51: Custom calling conventions](https://hex-rays.com/blog/igors-tip-of-the-week-51-custom-calling-conventions/)

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-164-wheres-my-code-the-case-of-missing-function-arguments
