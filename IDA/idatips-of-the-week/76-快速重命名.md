在 IDA 7.6 中新增了一个功能：自动变量重命名。

![](assets/2022/02/rename1.png)

与 `PIT` (Parameter Identification and Tracking) 不同，它不仅限于栈变量，还能处理寄存器中的变量，并且不仅适用于函数调用，还能应用于赋值和其他表达式。

它还会尝试根据函数名中的动词（如 `get`、`make`、`fetch`、`query` 等）来推断返回值的含义，并自动重命名结果变量。

### 手动触发 Quick rename

在自动重命名失败或不足时，可以使用手动操作 `Quick rename`（默认快捷键 `Shift–N`）。 它可以在赋值和其他表达式中传播变量名。通常只会重命名那些用户未显式命名的临时变量（如 `v1`、`v2` 等）。

- 按赋值另一侧变量名： `v1 = myvar` → `v1` 重命名为 `myvar1`
- 按比较另一侧变量名： `offset < v1` → `v1` 重命名为 `offset1`
- 指针： `v1 = &Value` → `v1` 重命名为 `p_Value`
- 结构体字段： `v1 = x.Next` → `v1` 重命名为 `Next`
- 指向结构体字段的指针： `v1 = &x.left` → `v1` 重命名为 `p_left`
- 按函数参数名： `close(v1)` → `v1` 重命名为 `fd`
- 按调用函数名： `v1 = create_table()` → `v1` 重命名为 `table`
- 按返回类型： `v1 = strchr(s, '1')` → `v1` 重命名为 `str`
- 按字符串常量： `v1 = fopen("/etc/fstab", "r")` → `v1` 重命名为 `etc_fstab`
- 按变量类型： `error_t v1` → `v1` 重命名为 `error`
- 标准返回变量： `return v1`（函数返回 `bool`） → `v1` 重命名为 `ok`

### 示例：Windows 驱动

以 `Process Hacker` 使用的内核驱动 `kprocesshacker.sys` 为例：

打开后，IDA 会自动应用已知的 `DriverEntry` 原型，并加载内核模式 `type libraries`，因此初始反编译结果已经比较清晰。

```c
NTSTATUS __stdcall DriverEntry(_DRIVER_OBJECT *DriverObject, PUNICODE_STRING RegistryPath)
{
  NTSTATUS result; // eax
  NTSTATUS v5; // r11d
  PDEVICE_OBJECT v6; // rax
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF
  PDEVICE_OBJECT DeviceObject; // [rsp+60h] [rbp+8h] BYREF

  qword_132C0 = (__int64)DriverObject;
  VersionInformation.dwOSVersionInfoSize = 284;
  result = RtlGetVersion(&VersionInformation);
  if ( result >= 0 )
  {
    result = sub_15100(RegistryPath);
    if ( result >= 0 )
    {
      RtlInitUnicodeString(&DestinationString, L"\\Device\\KProcessHacker3");
      result = IoCreateDevice(DriverObject, 0, &DestinationString, 0x22u, 0x100u, 0, &DeviceObject);
      v5 = result;
      if ( result >= 0 )
      {
        v6 = DeviceObject;
        DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)&sub_11008;
        qword_132D0 = (__int64)v6;
        DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)&sub_1114C;
        DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)&sub_11198;
        DriverObject->DriverUnload = (PDRIVER_UNLOAD)sub_150EC;
        v6->Flags &= ~0x80u;
        return v5;
      }
    }
  }
  return result;
}
```

但 `MajorFunction` 数组的索引其实是 `IRP Major Function Codes`，可以通过 `Enum action` (`M` hotkey) 转换为符号常量（如 `IRP_MJ_CREATE`）。

![](assets/2022/02/rename2_enum.png)

然后可以重命名对应的分发函数，使伪代码更接近标准的 `DriverEntry`。

![](assets/2022/02/rename3.png)

使用 `Set item type` (`Y` hotkey) 为分发函数设置正确的原型，例如：

```c
NTSTATUS Dispatch(PDEVICE_OBJECT Device, PIRP Irp)
```

卸载函数的原型不同：

```c
void Unload(PDRIVER_OBJECT Driver)
```

这样就能消除多余的强制类型转换。

![](assets/2022/02/rename4.png)

在 `KhDispatchDeviceControl` 中，`CurrentStackLocation->Parameters` 实际上是一个 `union`。

```c
NTSTATUS __stdcall KhDispatchDeviceControl(PDEVICE_OBJECT Device, PIRP Irp)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v13 = Irp;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  FsContext = CurrentStackLocation->FileObject->FsContext;
  Parameters = CurrentStackLocation->Parameters.CreatePipe.Parameters;
  Options = CurrentStackLocation->Parameters.Create.Options;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  AccessMode = Irp->RequestorMode;
  if ( !FsContext )
  {
    v9 = -1073741595;
    goto LABEL_105;
  }
  if ( LowPart != -1718018045
    && LowPart != -1718018041
    && (dword_132CC == 2 || dword_132CC == 3)
    && (*FsContext & 2) == 0 )
```

IDA 默认选择了第一个匹配字段，但对 `IRP_MJ_DEVICE_CONTROL` 来说，正确的应该是` DeviceIoControl`。

![](assets/2022/02/rename5.png)

使用 `Select union field` (`Alt–Y`) 可以切换到正确的字段。

![](assets/2022/02/rename6.png)

然后用 `Quick rename` (`Shift–N`) 更新变量名，使伪代码更符合逻辑。

![](assets/2022/02/rename7.png)

刷新反编译（`F5`）后，IDA 会重新推导类型，消除不必要的强制类型转换。

最终结果更接近真实逻辑，例如检查 `IoControlCode` 是否匹配预期值，而不是错误地比较 `LowPart`。

![](assets/2022/02/rename8.png)

### 其他用途

当自动重命名因命名冲突失败时，`Quick rename` 也很有用。

例如在 `DriverEntry` 中，我们可以看到，将 `DeviceObject` 复制到临时变量 `V6`：

```
        v6 = DeviceObject;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = KhDispatchCreate;
        qword_132D0 = (__int64)v6;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = KhDispatchClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KhDispatchDeviceControl;
        DriverObject->DriverUnload = KhUnload;
        v6->Flags &= ~0x80u;
```

使用 `Shift–N` 后，IDA 会自动生成 `DeviceObject1`，避免冲突。

```
        DeviceObject1 = DeviceObject;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = KhDispatchCreate;
        qword_132D0 = (__int64)DeviceObject1;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = KhDispatchClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KhDispatchDeviceControl;
        DriverObject->DriverUnload = KhUnload;
        DeviceObject1->Flags &= ~0x80u;
```

总结：

`Quick rename` 是 IDA 7.6 引入的一个强大功能，能在反编译器中快速传播变量名，让伪代码更接近真实语义，减少手动重命名的工作量。

原文地址：https://hex-rays.com/blog/igors-tip-of-the-week-76-quick-rename
